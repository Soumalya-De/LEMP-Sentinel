name: CI - secrets + smoke tests

on:
  push:
  pull_request:

jobs:
  secret-scan:
    name: Secret scan (gitleaks)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Run gitleaks (detect high-confidence secrets)
        run: |
          docker run --rm -v "$PWD":/repo zricethezav/gitleaks:latest detect \
            --source /repo \
            --verbose --redact --exit-code 1

  smoke-tests:
    name: Build, start and smoke-test stack
    runs-on: ubuntu-latest
    needs: secret-scan
    env:
      COMPOSE_HTTP_TIMEOUT: 200
      # Hard defaults to avoid blank build args/env in CI
      NGINX_BASE_IMAGE: nginx:alpine
      PHP_BASE_IMAGE: php:8.2-fpm-alpine
      DB_HOST: mysql
      DB_NAME: my_app_db
      DB_USER: app_user
      DB_PASSWORD: app_pass
      MYSQL_ROOT_PASSWORD: rootpass
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Resolve image digests (main only)
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          # Resolve digests for reproducibility
          NGINX_TAG=nginx:alpine
          PHP_TAG=php:8.2-fpm-alpine
          docker pull "$NGINX_TAG" >/dev/null
          docker pull "$PHP_TAG" >/dev/null
          NGINX_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$NGINX_TAG")
          PHP_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$PHP_TAG")
          echo "NGINX_BASE_IMAGE=$NGINX_DIGEST" >> $GITHUB_ENV
          echo "PHP_BASE_IMAGE=$PHP_DIGEST" >> $GITHUB_ENV


      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Show Docker and Compose versions
        run: |
          docker --version
          docker compose version

      - name: Validate docker-compose.yml
        run: docker compose config


      - name: PHP lint (syntax check all PHP files)
        run: |
          docker run --rm -v "$PWD/www":/app -w /app php:8.2-cli sh -lc '
            set -e
            if ls *.php >/dev/null 2>&1; then
              php -v
              for f in $(find . -name "*.php"); do php -l "$f"; done
            else
              echo "No PHP files to lint"
            fi
          '

      - name: Validate bcrypt helper outputs bcrypt hash
        run: |
          set -e
          out=$(docker run --rm -v "$PWD/scripts":/scripts php:8.2-cli php /scripts/bcrypt.php 'secret123')
          echo "Hash: $out"
          case "$out" in
            \$2y\$*) echo "Looks like bcrypt" ;;
            *) echo "Unexpected hash format: $out"; exit 1 ;;
          esac

      - name: Build and start stack
        run: |
          docker compose up --build -d
        timeout-minutes: 10

      - name: Wait for /test-db.php (max 90s)
        run: |
          set -e
          attempts=0
          max=45
          until curl -sSf http://localhost:8080/test-db.php > /dev/null 2>&1 || [ $attempts -ge $max ]; do
            attempts=$((attempts+1))
            echo "Waiting for test-db.php ($attempts/$max)..."
            sleep 2
          done
          if [ $attempts -ge $max ]; then
            echo "Timeout waiting for test-db.php"
            docker compose logs --tail=200
            exit 1
          fi

      - name: Run smoke checks
        run: |
          set -e
          echo "Checking /"
          curl -sSf http://localhost:8080/ | head -n 2
          echo "Checking /test-db.php"
          curl -sSf http://localhost:8080/test-db.php
          echo "Checking /info.php (should be 403 unless APP_ENV=development)"
          status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/info.php)
          echo "info.php returned $status"

      - name: Backup database dump
        run: |
          set -e
          make db-backup

      - name: Upload DB dump artifact
        uses: actions/upload-artifact@v4
        with:
          name: mysql-backup
          path: backups/my_app_db.sql

      - name: Simulate data loss (drop tables)
        run: |
          set -e
          docker exec -i -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" lemp_mysql \
            mysql -uroot "$DB_NAME" -e 'DROP TABLE IF EXISTS posts; DROP TABLE IF EXISTS users;'

      - name: Validate failure after drop (test-db.php should error)
        run: |
          set +e
          code=$(curl -s -o /tmp/out.json -w "%{http_code}" http://localhost:8080/test-db.php)
          echo "HTTP: $code" && cat /tmp/out.json || true
          # Do not fail the pipeline here; proceed to restore

      - name: Restore database from dump
        run: |
          set -e
          make db-restore

      - name: Validate after restore (test-db.php success)
        run: |
          set -e
          curl -sSf http://localhost:8080/test-db.php | jq -r '.overall_status'

      - name: Tear down stack
        if: always()
        run: docker compose down --volumes --remove-orphans

  supply-chain:
    name: SBOM + Image Scan (non-blocking)
    runs-on: ubuntu-latest
    needs: smoke-tests
    env:
      # Ensure compose builds use sane defaults here as well
      NGINX_BASE_IMAGE: nginx:alpine
      PHP_BASE_IMAGE: php:8.2-fpm-alpine
      DB_HOST: mysql
      DB_NAME: my_app_db
      DB_USER: app_user
      DB_PASSWORD: app_pass
      MYSQL_ROOT_PASSWORD: rootpass
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Resolve image digests (main only)
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          NGINX_TAG=nginx:alpine
          PHP_TAG=php:8.2-fpm-alpine
          docker pull "$NGINX_TAG" >/dev/null
          docker pull "$PHP_TAG" >/dev/null
          NGINX_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$NGINX_TAG")
          PHP_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$PHP_TAG")
          echo "NGINX_BASE_IMAGE=$NGINX_DIGEST" >> $GITHUB_ENV
          echo "PHP_BASE_IMAGE=$PHP_DIGEST" >> $GITHUB_ENV

      - name: Set up Syft and Grype/Trivy
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOM for repository
        run: |
          syft dir:. -o spdx-json > sbom.spdx.json || true

      - name: Build images locally for scan
        run: |
          docker compose build --pull

      - name: Scan local images with Trivy (PRs - non-blocking)
        if: github.event_name == 'pull_request'
        run: |
          set -e
          for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'nginx:|php:' | sort -u); do
            echo "Scanning $img (informational)"
            trivy image --severity HIGH,CRITICAL --no-progress --timeout 5m --format table "$img" || true
          done

      - name: Scan local images with Trivy (main - blocking)
        if: github.event_name != 'pull_request'
        run: |
          set -e
          for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'nginx:|php:' | sort -u); do
            echo "Scanning $img (blocking)"
            trivy image --severity HIGH,CRITICAL --no-progress --timeout 5m --exit-code 1 --format table "$img"
          done

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json
