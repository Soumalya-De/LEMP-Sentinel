name: CI - secrets + smoke tests

on:
  push:
  pull_request:

jobs:
  secret-scan:
    name: Secret scan (gitleaks)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Run gitleaks (detect high-confidence secrets)
        run: |
          docker run --rm -v "$PWD":/repo zricethezav/gitleaks:latest detect \
            --source /repo \
            --verbose --redact --exit-code 1

  smoke-tests:
    name: Build, start and smoke-test stack
    runs-on: ubuntu-latest
    needs: secret-scan
    env:
      COMPOSE_HTTP_TIMEOUT: 200
      RUN_DB_BACKUP_RESTORE: "false"
      # Enable dev-only diagnostics used by smoke tests
      APP_ENV: development
      # Hard defaults to avoid blank build args/env in CI
      NGINX_BASE_IMAGE: nginx:alpine
      PHP_BASE_IMAGE: php:8.2-fpm-alpine
      DB_HOST: mysql
      DB_NAME: my_app_db
      DB_USER: app_user
      DB_PASSWORD: app_pass
      MYSQL_ROOT_PASSWORD: rootpass
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Resolve image digests (main only)
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          # Resolve digests for reproducibility
          NGINX_TAG=nginx:alpine
          PHP_TAG=php:8.2-fpm-alpine
          docker pull "$NGINX_TAG" >/dev/null
          docker pull "$PHP_TAG" >/dev/null
          NGINX_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$NGINX_TAG")
          PHP_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$PHP_TAG")
          echo "NGINX_BASE_IMAGE=$NGINX_DIGEST" >> $GITHUB_ENV
          echo "PHP_BASE_IMAGE=$PHP_DIGEST" >> $GITHUB_ENV


      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Show Docker and Compose versions
        run: |
          docker --version
          docker compose version

      - name: Validate docker-compose.yml
        run: docker compose config


      - name: PHP lint (syntax check all PHP files)
        run: |
          docker run --rm -v "$PWD/www":/app -w /app php:8.2-cli sh -lc '
            set -e
            if ls *.php >/dev/null 2>&1; then
              php -v
              for f in $(find . -name "*.php"); do php -l "$f"; done
            else
              echo "No PHP files to lint"
            fi
          '

      - name: Validate bcrypt helper outputs bcrypt hash
        run: |
          set -e
          out=$(docker run --rm -v "$PWD/scripts":/scripts php:8.2-cli php /scripts/bcrypt.php 'secret123')
          echo "Hash: $out"
          case "$out" in
            \$2y\$*) echo "Looks like bcrypt" ;;
            *) echo "Unexpected hash format: $out"; exit 1 ;;
          esac

      - name: Build and start stack
        run: |
          docker compose up --build -d
        timeout-minutes: 10

      - name: Wait for /test-db.php (max 90s)
        run: |
          set -e
          attempts=0
          max=45
          until curl -sSf http://localhost:8080/test-db.php > /dev/null 2>&1 || [ $attempts -ge $max ]; do
            attempts=$((attempts+1))
            echo "Waiting for test-db.php ($attempts/$max)..."
            sleep 2
          done
          if [ $attempts -ge $max ]; then
            echo "Timeout waiting for test-db.php"
            docker compose logs --tail=200
            exit 1
          fi

      - name: Run smoke checks
        run: |
          set -e
          echo "Checking /"
          curl -sSf http://localhost:8080/ | head -n 2
          echo "Checking /test-db.php"
          curl -sSf http://localhost:8080/test-db.php
          echo "Checking /info.php (should be 403 unless APP_ENV=development)"
          status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/info.php)
          echo "info.php returned $status"

      - name: Backup database dump
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        run: |
          set -e
          echo "Dumping $DB_NAME to backups/my_app_db.sql"
          mkdir -p backups
          # Use container env values and non-interactive auth; avoid PROCESS privilege warning
          docker exec -i lemp_mysql \
            sh -lc 'MYSQL_PWD="$MYSQL_PASSWORD" exec mysqldump --no-tablespaces -u "$MYSQL_USER" "$MYSQL_DATABASE"' > backups/my_app_db.sql
          echo "Backup written to backups/my_app_db.sql"

      - name: Upload DB dump artifact
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        uses: actions/upload-artifact@v5
        with:
          name: mysql-backup
          path: backups/my_app_db.sql

      - name: MySQL pre-check (auth and env)
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        run: |
          set -e
          echo "Job env DB_NAME=$DB_NAME"
          echo "Container MYSQL_DATABASE=$(docker exec lemp_mysql printenv MYSQL_DATABASE)"
          # Simple auth check; do not print results to avoid leaking creds
          docker exec -i lemp_mysql sh -lc 'MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql -uroot -e "SELECT 1" "$MYSQL_DATABASE" >/dev/null'

      - name: Simulate data loss (drop tables)
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        run: |
          set -e
          docker exec -i lemp_mysql \
            sh -lc 'MYSQL_PWD="$MYSQL_ROOT_PASSWORD" exec mysql -uroot "$MYSQL_DATABASE" -e "DROP TABLE IF EXISTS posts; DROP TABLE IF EXISTS users;"'

      - name: Validate failure after drop (test-db.php should error)
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        run: |
          set +e
          code=$(curl -s -o /tmp/out.json -w "%{http_code}" http://localhost:8080/test-db.php)
          echo "HTTP: $code" && cat /tmp/out.json || true
          # Do not fail the pipeline here; proceed to restore

      - name: Restore database from dump
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        run: |
          set -e
          docker exec -i lemp_mysql \
            sh -lc 'MYSQL_PWD="$MYSQL_PASSWORD" exec mysql -u "$MYSQL_USER" "$MYSQL_DATABASE"' < backups/my_app_db.sql

      - name: Validate after restore (test-db.php success)
        if: env.RUN_DB_BACKUP_RESTORE == 'true'
        run: |
          set -e
          curl -sSf http://localhost:8080/test-db.php | jq -r '.overall_status'

      - name: Tear down stack
        if: always()
        run: docker compose down --volumes --remove-orphans

  supply-chain:
    name: SBOM + Image Scan (non-blocking)
    runs-on: ubuntu-latest
    needs: smoke-tests
    env:
      # Ensure compose builds use sane defaults here as well
      NGINX_BASE_IMAGE: nginx:alpine
      PHP_BASE_IMAGE: php:8.2-fpm-alpine
      DB_HOST: mysql
      DB_NAME: my_app_db
      DB_USER: app_user
      DB_PASSWORD: app_pass
      MYSQL_ROOT_PASSWORD: rootpass
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Resolve image digests (main only)
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          NGINX_TAG=nginx:alpine
          PHP_TAG=php:8.2-fpm-alpine
          docker pull "$NGINX_TAG" >/dev/null
          docker pull "$PHP_TAG" >/dev/null
          NGINX_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$NGINX_TAG")
          PHP_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$PHP_TAG")
          echo "NGINX_BASE_IMAGE=$NGINX_DIGEST" >> $GITHUB_ENV
          echo "PHP_BASE_IMAGE=$PHP_DIGEST" >> $GITHUB_ENV

      - name: Set up Syft
        run: |
          wget -qO- https://github.com/anchore/syft/releases/download/v1.18.1/syft_1.18.1_linux_amd64.tar.gz | tar xz -C /usr/local/bin syft
          syft version

      - name: Set up Trivy
        run: |
          wget -qO- https://github.com/aquasecurity/trivy/releases/download/v0.67.2/trivy_0.67.2_Linux-64bit.tar.gz | tar xz -C /usr/local/bin trivy
          trivy version

      - name: Generate SBOM for repository
        run: |
          syft dir:. -o spdx-json > sbom.spdx.json || true

      - name: Build images locally for scan
        run: |
          docker compose build --pull

      - name: Scan local images with Trivy (PRs - non-blocking)
        if: github.event_name == 'pull_request'
        run: |
          set -e
          mkdir -p trivy-results
          for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'nginx:|php:' | sort -u); do
            safe=$(echo "$img" | sed 's/[^A-Za-z0-9._-]/_/g')
            out="trivy-results/${safe}.sarif"
            echo "Scanning $img -> $out (informational)"
            trivy image --format sarif --severity HIGH,CRITICAL --output "$out" --no-progress --timeout 5m "$img" || true
          done
          ls -lah trivy-results || true

      - name: Scan local images with Trivy (main - blocking)
        if: github.event_name != 'pull_request'
        run: |
          set -e
          mkdir -p trivy-results
          scan_rc=0
          for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'nginx:|php:' | sort -u); do
            safe=$(echo "$img" | sed 's/[^A-Za-z0-9._-]/_/g')
            out="trivy-results/${safe}.sarif"
            echo "Scanning $img -> $out (blocking)"
            trivy image --format sarif --severity HIGH,CRITICAL --output "$out" --no-progress --timeout 5m "$img" || scan_rc=$?
          done
          ls -lah trivy-results || true
          # Fail the job if any scan returned a non-zero exit code
          if [ "$scan_rc" -ne 0 ]; then
            echo "Trivy detected HIGH/CRITICAL vulnerabilities (scan_rc=$scan_rc)"
            # Print brief summaries
            for f in trivy-results/*.sarif; do
              echo "---- $f ----"
              jq -r '.runs[].results[]?.level' "$f" 2>/dev/null | sort -u || true
            done
            exit $scan_rc
          fi

      - name: Upload SBOM
        uses: actions/upload-artifact@v5
        with:
          name: sbom
          path: sbom.spdx.json

      - name: Upload Trivy SARIF results (if any)
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: trivy-sarif
          path: trivy-results/*.sarif
